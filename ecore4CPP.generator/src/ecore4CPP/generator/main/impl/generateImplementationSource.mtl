[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateImplementationSource('http://www.eclipse.org/emf/2002/Ecore')]

[import ecore4CPP::generator::main::generateAttribute/]
[import ecore4CPP::generator::main::generateOperation/]
[import ecore4CPP::generator::main::generateReference/]
[import ecore4CPP::generator::main::generateStructuralFeatureSetGet /]
[import ecore4CPP::generator::main::generateType/]
[import ecore4CPP::generator::main::generateUnion /]
[import ecore4CPP::generator::main::generateModel /]
[import ecore4CPP::generator::main::helper /]

[template public generateImplementationSource(aClass : EClass) { className : String = aClass.name.toUpperFirst().concat('Impl'); }]
[file (aClass.ePackage.name.concat('/impl/').concat(className).concat('.cpp'), false, 'UTF-8')]
#include "[className.concat('.hpp')/]"
#include <iostream>
#include <cassert>
#include "EAnnotation.hpp"
#include "EClass.hpp"
#include "[aClass.ePackage.name.concat('PackageImpl')/].hpp"
[if (aClass.hasKey('includes'))]
[aClass.valueKey('includes')/]
[/if]

//Forward declaration includes
[for (element : EClassifier| aClass.includes()->selectByKind(EClass)->asOrderedSet()->sortedBy(name)) separator ('\n')]
#include "[element.name/].hpp"
[/for]


[comment namespace /]
using namespace [aClass.ePackage.name/];

//*********************************
// Constructor / Destructor
//*********************************
[className/]::[className/]()
{
	//*********************************
	// Attribute Members
	//*********************************
	[for (aAttribute : EAttribute | aClass.eAttributes->asOrderedSet()->sortedBy(name)) separator ('\n')]
	[aAttribute.generateAttributeInit()/][/for]

	//*********************************
	// Reference Members
	//*********************************
	[comment]References must be initialized in this order:
	1st Unions
	2nd Subset Unions
	3rd Subsets that should be unions
	4th all the rest.
	[/comment]
	//References
	[for (aReference : EReference | aClass.eReferences->asOrderedSet()->sortedBy(name)) separator ('\n')]
	[aReference.generateReferenceInit()/]
	[/for]

	//Init references
	[for (aReference : EReference | aClass.eReferences->asOrderedSet()->sortedBy(name)) separator ('\n')]
	[aReference.InitReferences()/]
	[/for]
}

[className/]::~[className/]()
{
#ifdef SHOW_DELETION
	std::cout << "-------------------------------------------------------------------------------------------------\r\ndelete [aClass.name.toUpperFirst()/] "<< this << "\r\n------------------------------------------------------------------------ " << std::endl;
#endif
	[aClass.eReferences.generateProtectedReferenceDeleter()/]
}

[comment]Don't forget to call the class contructor before initializing the unions and subsets![/comment]
[className/]::[className/](const [className/] & obj):[className/]()
{
	//create copy of all Attributes
	#ifdef SHOW_COPIES
	std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\ncopy [aClass.name.toUpperFirst()/] "<< this << "\r\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ " << std::endl;
	#endif
	[for (att : EAttribute | aClass.eAllAttributes->asOrderedSet()->sortedBy(name))]
	m_[att.name/] = obj.[att.GetterName()/]();
	[/for]

	//copy references with no containment (soft copy)
	
	[for (ref : EReference | aClass.eAllReferences->select(aRef: EReference | aRef.containment = false and not aRef.hasSubset())->asOrderedSet()->sortedBy(name))]
	[if (ref.hasSetter() or ref.upperBound = 1)]
	m_[ref.name/]  = obj.[ref.GetterName()/]();
	[else]
	[ref.generateReferenceType()/] _[ref.name/] = obj.[ref.GetterName()/]();
	m_[ref.name/].reset(new [ref.generateReferenceType(false)/](*(obj.[ref.GetterName()/]().get())));
	[/if]

	[/for]

	[comment]//copy references with no containment
	
	[for (ref : EReference | aClass.eAllReferences->select(containment = false)->asOrderedSet()->sortedBy(name))]
	[if (ref.hasSetter() or ref.upperBound = 1)]
	m_[ref.name/]  = obj.[ref.GetterName()/]();
	[else]
	[ref.generateReferenceType()/] _[ref.name/] = obj.[ref.GetterName()/]();
	m_[ref.name/].reset(new [ref.generateReferenceType(false)/](*(obj.[ref.GetterName()/]().get())));
	[/if]

	[/for]

	//clone containt lists
	[for (ref : EReference | aClass.eAllReferences->select(containment = true)->asOrderedSet()->sortedBy(name))][/comment]
    
	[comment]References must be copied in this order:
	1st Unions
	2nd Subset Unions
	3rd all the rest.
	[/comment]
	//Clone references with containment (deep copy)

	[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = true or eRef.hasSubset()) and (not eRef.isUnion()))->asOrderedSet()->sortedBy(name))]
	[if (ref.hasSetter() or ref.upperBound = 1)]
	if(obj.[ref.GetterName()/]()!=nullptr)
	{
		[if(ref.upperBound=1)]
		m_[ref.name/].reset(dynamic_cast<[ref.eType.generateType()/]*>(obj.[ref.GetterName()/]()->copy()));
		[else]
		m_[ref.name/].reset(dynamic_cast<Bag<[ref.eType.generateType()/]>* >(obj.[ref.GetterName()/]()->copy()));
		[/if]
	}
	[else]
	std::shared_ptr<Bag<[ref.eType.generateType()/]>> _[ref.name/]List = obj.[ref.GetterName()/]();
	for(std::shared_ptr<[ref.eType.generateType()/]> _[ref.name/] : *_[ref.name/]List)
	{
		this->[ref.GetterName()/]()->add(std::shared_ptr<[ref.eType.generateType()/]>(dynamic_cast<[ref.eType.generateType()/]*>(_[ref.name/]->copy())));
	}
	[/if]
	#ifdef SHOW_SUBSET_UNION
		std::cout << "Copying the Subset: " << "m_[ref.name/]" << std::endl;
	#endif
	[/for]

	[for (aReference : EReference | aClass.eReferences->select(eRef: EReference|eRef.containment = true and not eRef.isUnion())->asOrderedSet()->sortedBy(name)) separator ('\n')]
	[aReference.InitReferences()/]
	[/for]

	[comment][for (ref : EReference | (aClass.eAllReferences->select(aReference : EReference | aReference.isUnion() and not(aReference.hasSubset())))->asOrderedSet()->sortedBy(name))]
	[if (ref.hasSetter() or ref.upperBound = 1)]
	m_[ref.name/]  = obj.[ref.GetterName()/]();
	[else]
	[ref.generateReferenceType()/] _[ref.name/] = obj.[ref.GetterName()/]();
	m_[ref.name/].reset(new [ref.generateReferenceType(false)/](*(obj.[ref.GetterName()/]().get())));// this->[ref.GetterName()/]()->insert(this->[ref.GetterName()/]()->end(), _[ref.name/]->begin(), _[ref.name/]->end());
	[/if]
	#ifdef SHOW_SUBSET_UNION
		std::cout << "Copying Union: " << "m_[ref.name/]" << std::endl;
	#endif
	[/for]

	//Copy the SubsetUnions
	[for (ref : EReference | (aClass.eAllReferences->select(aReference : EReference | aReference.isSubsetUnion()))->asOrderedSet()->sortedBy(name))]
	[if (ref.hasSetter() or ref.upperBound = 1)]
	m_[ref.name/]  = obj.[ref.GetterName()/]();
	[else]
	[ref.generateReferenceType()/] _[ref.name/] = obj.[ref.GetterName()/]();
	m_[ref.name/].reset(new [ref.generateReferenceType(false)/](*(obj.[ref.GetterName()/]().get())));// this->[ref.GetterName()/]()->insert(this->[ref.GetterName()/]()->end(), _[ref.name/]->begin(), _[ref.name/]->end());
	[/if]
	#ifdef SHOW_SUBSET_UNION
		std::cout << "Copying SubsetUnion: " << "m_[ref.name/]" << std::endl;
	#endif
	[/for]

	//Clone the subset that should be unions too
	[for (ref : EReference | (aClass.eAllReferences->select(aReference : EReference | (not aReference.isUnion()) and aReference.subsetIsUnion()))->asOrderedSet()->sortedBy(name))]
	[if (ref.hasSetter() or ref.upperBound = 1)]
	m_[ref.name/]  = obj.[ref.GetterName()/]();
	[else]
	[ref.generateReferenceType()/] _[ref.name/] = obj.[ref.GetterName()/]();
	m_[ref.name/].reset(new [ref.generateReferenceType(false)/](*(obj.[ref.GetterName()/]().get())));// this->[ref.GetterName()/]()->insert(this->[ref.GetterName()/]()->end(), _[ref.name/]->begin(), _[ref.name/]->end());
	[/if]
	#ifdef SHOW_SUBSET_UNION
		std::cout << "Copying Subset that should be a union: " << "m_[ref.name/]" << std::endl;
	#endif
	[/for]

	//Clone the rest
	[for (ref : EReference | (aClass.eAllReferences->select(aReference : EReference | aReference.hasSubset() and not(aReference.subsetIsUnion()) and not(aReference.isUnion())))->asOrderedSet()->sortedBy(name))]
	[if (ref.hasSetter() or ref.upperBound = 1)]
	if(obj.[ref.GetterName()/]()!=nullptr)
	{
		[if(ref.upperBound=1)]
		m_[ref.name/].reset(dynamic_cast<[ref.eType.generateType()/]*>(obj.[ref.GetterName()/]()->copy()));
		[else]
		m_[ref.name/].reset(dynamic_cast<Bag<[ref.eType.generateType()/]>* >(obj.[ref.GetterName()/]()->copy()));
		[/if]
	}
	[else]
	std::shared_ptr<Bag<[ref.eType.generateType()/]>> _[ref.name/]List = obj.[ref.GetterName()/]();
	for(std::shared_ptr<[ref.eType.generateType()/]> _[ref.name/] : *_[ref.name/]List)
	{
		this->[ref.GetterName()/]()->add(std::shared_ptr<[ref.eType.generateType()/]>(dynamic_cast<[ref.eType.generateType()/]*>(_[ref.name/]->copy())));
	}
	[/if]
	#ifdef SHOW_SUBSET_UNION
		std::cout << "Copying the Subset: " << "m_[ref.name/]" << std::endl;
	#endif
	[/for][/comment]
}

ecore::EObject *  [className/]::copy() const
{
	return new [className/](*this);
}

std::shared_ptr<[needNamespace(aClass.ePackage, 'EClass')/]> [className/]::eStaticClass() const
{
	return [aClass.ePackage.name.concat('PackageImpl').toUpperFirst()/]::eInstance()->get[aClass.name.toUpperFirst()/]();
}

//*********************************
// Attribute Setter Gettter
//*********************************
[for (aAttribute : EAttribute | aClass.eAttributes->asOrderedSet()->sortedBy(name)) separator ('\n')]
[aAttribute.generateAttributeSetterImplementationCpp(true)/]

[aAttribute.generateAttributeGetterImplementationCpp()/]
[/for]

//*********************************
// Operations
//*********************************
[for (aOperation : EOperation | aClass.eOperations->asOrderedSet()->sortedBy(name)) separator ('\n')]
[aOperation.generateOperationImplementation()/]
[/for]

//*********************************
// References
//*********************************
[for (aReference : EReference | aClass.eReferences->asOrderedSet()->sortedBy(name)) separator ('\n')]
[aReference.generateReferenceCpp()/]
[/for]

//*********************************
// Union Getter
//*********************************
[aClass.generateUnionGetterCpp()/]

//*********************************
// Structural Feature Getter/Setter
//*********************************
[aClass.generateeGetImpl()/]

//*********************************
// Persistence Functions
//*********************************
void [aClass.name.concat('Impl')/]::save(std::shared_ptr<persistence::XHandler> handler) const
{
	//
	// Add attributes
	//
[for (aAttribute : EAttribute | aClass.eAllAttributes->select(eAtt: EAttribute|(eAtt.transient = false))->asOrderedSet()->sortedBy(name)) separator ('\n')]
[if (not(aAttribute.upperBound = 1))]
	handler->addAttribute( "[aAttribute.name/]", this->[aAttribute.GetterName()/]() ); // upperBound != 1 so [aAttribute.GetterName()/]() is a list/bag/union 
[else]
	[if (aAttribute.defaultValueLiteral->notEmpty())]
	if ( this->[aAttribute.GetterName()/]() != [if (aAttribute.eType.oclIsTypeOf(EEnum))][aAttribute.eType.name/]::[aAttribute.defaultValueLiteral.toUpperCase()/][else][aAttribute.defaultValueLiteral/][/if] ) // default: [aAttribute.name/] = [if (aAttribute.eType.oclIsTypeOf(EEnum))][aAttribute.eType.name/]::[aAttribute.defaultValueLiteral.toUpperCase()/][else][aAttribute.defaultValueLiteral/][/if]
	{
		handler->addAttribute( "[aAttribute.name/]", this->[aAttribute.GetterName()/]() );
	}
	[else]
	handler->addAttribute( "[aAttribute.name/]", this->[aAttribute.GetterName()/]() );
	[/if]
[/if]
[/for]

[comment]
//1.0 (eRef.containment = false)
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = false))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]

//1.1 (eRef.containment = true)
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = true))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]

//2.0 (eRef.containment = false or eRef.hasSubset()) and (not eRef.isUnion())
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = false or eRef.hasSubset()) and (not eRef.isUnion()))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]

//2.1 (eRef.containment = false or eRef.hasSubset()) and (eRef.isUnion())
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = false or eRef.hasSubset()) and (eRef.isUnion()))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]

//2.2 (eRef.containment = true or eRef.hasSubset()) and (not eRef.isUnion())
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = true or eRef.hasSubset()) and (not eRef.isUnion()))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]

//2.3 (eRef.containment = true or eRef.hasSubset()) and (eRef.isUnion())
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = true or eRef.hasSubset()) and (eRef.isUnion()))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]

//3.0 (eRef.containment = true or eRef.hasSubset())
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = true or eRef.hasSubset()))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]

//3.1 (eRef.containment = false or eRef.hasSubset())
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = false or eRef.hasSubset()))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]

//4.0 (eRef.containment = true) and (not eRef.isUnion())
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = true ) and (not eRef.isUnion()))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]

//4.1 (eRef.containment = true) and (eRef.isUnion())
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = true) and (eRef.isUnion()))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]

//4.2 (eRef.containment = false) and (not eRef.isUnion())
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = false) and (not eRef.isUnion()))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]

//4.3 (eRef.containment = false) and (eRef.isUnion())
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = false ) and (eRef.isUnion()))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]


//5.0 (eRef.hasSubset()) and (not eRef.isUnion())
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.hasSubset()) and (not eRef.isUnion()))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]

//5.1 (eRef.hasSubset()) and (eRef.isUnion())
[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.hasSubset()) and (eRef.isUnion()))->asOrderedSet()->sortedBy(name))]
[ref.name/]
[/for]

//6 sollte funktionieren (ungetestet)
[for (aReference : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = false ))->asOrderedSet()->sortedBy(name))]
[if (hasDocKeyX('suppressedIsSetVisibility'))]
	handler->addReference("[aReference.name/]", this->[aReference.GetterName()/]());
[else]
// [aReference.name/]
[/if]
[/for]

[/comment]

	//
	// Add references
	//
[for (aReference : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = false) and (eRef.transient = false) and (eRef.unsettable = true))->asOrderedSet()->sortedBy(name))]
	handler->addReference("[aReference.name/]", this->[aReference.GetterName()/]());
[/for]
	//
	// Add new tags (from references)
	//
[for (aReference : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = true) and (eRef.transient = false))->asOrderedSet()->sortedBy(name)) separator ('\n')]
[if (aReference.upperBound = 1)]
	// TODO implement "aReference.upperBound = 1" for '[aReference.name/]'
[else]
	[aReference.generateReferenceType()/] list_[aReference.name/] = this->[aReference.GetterName()/]();

	if ( list_[aReference.name/]->size() != 0) {
		for ( std::shared_ptr<[aReference.eType.generateType()/]> [aReference.name/] : *list_[aReference.name/] ) {
			handler->createAndAddElement( "[aReference.name/]" );
					
			std::shared_ptr<ecore::EClass> meta_class = [aReference.name/]->eClass();
			if (meta_class->getName().compare("[aReference.eType.name/]") != 0)
			{
				handler->addAttribute( "xsi:type", handler->getType([aReference.name/]) );
			}
			[aReference.name/]->save( handler );
			handler->release();
		}
	}
[/if]
[/for]

}

[/file]
[/template]
[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateImplementationSource('http://www.eclipse.org/emf/2002/Ecore')]

[import ecore4CPP::generator::main::generateAttribute/]
[import ecore4CPP::generator::main::generateOperation/]
[import ecore4CPP::generator::main::generateReference/]
[import ecore4CPP::generator::main::generateStructuralFeatureSetGet /]
[import ecore4CPP::generator::main::generateType/]
[import ecore4CPP::generator::main::generateUnion /]
[import ecore4CPP::generator::main::generateModel /]
[import ecore4CPP::generator::main::helper /]

[template public generateImplementationSource(aClass : EClass) { className : String = aClass.name.toUpperFirst().concat('Impl'); }]
[file (aClass.ePackage.name.concat('/impl/').concat(className).concat('.cpp'), false, 'UTF-8')]
#include "[className.concat('.hpp')/]"
#include <iostream>
#include <cassert>
#include "EAnnotation.hpp"
#include "EClass.hpp"
#include "[aClass.ePackage.name.toUpperFirst().concat('PackageImpl')/].hpp"
[if (aClass.hasKey('includes'))]
[aClass.valueKey('includes')/]
[/if]

//Forward declaration includes
[for (element : EClassifier| aClass.includes()->selectByKind(EClass)->asOrderedSet()->sortedBy(name)) separator ('\n')]
#include "[element.name.toUpperFirst()/].hpp"
[/for]


[comment namespace /]
using namespace [aClass.ePackage.name/];

//*********************************
// Constructor / Destructor
//*********************************
[className/]::[className/]()
{
	//*********************************
	// Attribute Members
	//*********************************
	[for (aAttribute : EAttribute | aClass.eAttributes->asOrderedSet()->sortedBy(name)) separator ('\n')]
	[aAttribute.generateAttributeInit()/][/for]

	//*********************************
	// Reference Members
	//*********************************
	[comment]References must be initialized in this order:
	1st Unions
	2nd Subset Unions
	3rd Subsets that should be unions
	4th all the rest.
	[/comment]
	//References
	[for (aReference : EReference | aClass.eReferences->asOrderedSet()->sortedBy(name)) separator ('\n')]
	[aReference.generateReferenceInit()/]
	[/for]

	//Init references
	[for (aReference : EReference | aClass.eReferences->asOrderedSet()->sortedBy(name)) separator ('\n')]
	[aReference.InitReferences()/]
	[/for]
}

[className/]::~[className/]()
{
#ifdef SHOW_DELETION
	std::cout << "-------------------------------------------------------------------------------------------------\r\ndelete [aClass.name.toUpperFirst()/] "<< this << "\r\n------------------------------------------------------------------------ " << std::endl;
#endif
	[aClass.eReferences->sortedBy(name).generateProtectedReferenceDeleter()/]
}


[let ref:OrderedSet(EReference) = aClass.getAllContainers()]
[for(aReference:EReference | ref->sortedBy(name)) separator('\n')]
//Additional constructor for the containments back reference
[if(ref->select(eType.name = aReference.eType.name)->size()>1 )]
	[if(ref->select(eType.name = aReference.eType.name)->asOrderedSet()->sortedBy(name)->first() = aReference)]
			[className/]::[className/]([aReference.generateReferenceType(true)/] par_[aReference.eType.name/], const int reference_id)
			:[className/]()
			{
				switch(reference_id)
				{	
				[for(multipleRef : EReference | ref->select(eType.name = aReference.eType.name)->sortedBy(name))]
				case [aClass.ePackage.name.toUpperFirst()/]Package::[multipleRef.memberNameUpper()/]:
					 m_[multipleRef.name/] = par_[aReference.eType.name/];
					 return;
				[/for]
				default:
				std::cerr << __PRETTY_FUNCTION__ <<" Reference not found in class with the given ID" << std::endl;
				}
			   
			}
	[/if]
	[else]
			[className/]::[className/]([aReference.generateReferenceType(true)/] par_[aReference.name/])
			:[className/]()
			{
			    m_[aReference.name/] = par_[aReference.name/];
			}
	[/if]




[/for]
[/let]


[comment]Don't forget to call the class contructor before initializing the unions and subsets![/comment]
[className/]::[className/](const [className/] & obj):[className/]()
{
	//create copy of all Attributes
	#ifdef SHOW_COPIES
	std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\ncopy [aClass.name.toUpperFirst()/] "<< this << "\r\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ " << std::endl;
	#endif
	[for (att : EAttribute | aClass.eAllAttributes->asOrderedSet()->sortedBy(name))]
	m_[att.name/] = obj.[att.GetterName()/]();
	[/for]

	//copy references with no containment (soft copy)
	
	[for (ref : EReference | aClass.eAllReferences->select(aRef: EReference | aRef.isBackReference() or (aRef.containment = false and not aRef.hasSubset()))->asOrderedSet()->sortedBy(name))]
	[if (ref.hasSetter() or ref.upperBound = 1)]
	m_[ref.name/]  = obj.[ref.GetterName()/]();
	[else]
	[ref.generateReferenceType()/] _[ref.name/] = obj.[ref.GetterName()/]();
	m_[ref.name/].reset(new [ref.generateReferenceType(false)/](*(obj.[ref.GetterName()/]().get())));
	[/if]

	[/for]

	[comment]References must be copied in this order:
	1st Unions
	2nd Subset Unions
	3rd all the rest.
	[/comment]
	//Clone references with containment (deep copy)

	[for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = true or eRef.hasSubset()) and (not eRef.isUnion()) and (not eRef.isBackReference()))->asOrderedSet()->sortedBy(name))]
	[if (ref.hasSetter() or ref.upperBound = 1)]
	if(obj.[ref.GetterName()/]()!=nullptr)
	{
		[if(ref.upperBound=1)]
		m_[ref.name/] = std::dynamic_pointer_cast<[ref.eType.generateType()/]>(obj.[ref.GetterName()/]()->copy());
		[else]
		m_[ref.name/] = std::dynamic_pointer_cast<Bag<[ref.eType.generateType()/]>>(obj.[ref.GetterName()/]()->copy());
		[/if]
	}
	[else]
	std::shared_ptr<Bag<[ref.eType.generateType()/]>> _[ref.name/]List = obj.[ref.GetterName()/]();
	for(std::shared_ptr<[ref.eType.generateType()/]> _[ref.name/] : *_[ref.name/]List)
	{
		this->[ref.GetterName()/]()->add(std::shared_ptr<[ref.eType.generateType()/]>(std::dynamic_pointer_cast<[ref.eType.generateType()/]>(_[ref.name/]->copy())));
	}
	[/if]
	#ifdef SHOW_SUBSET_UNION
		std::cout << "Copying the Subset: " << "m_[ref.name/]" << std::endl;
	#endif
	[/for]

	[for (aReference : EReference | aClass.eReferences->select(eRef: EReference|eRef.containment = true and not eRef.isUnion())->asOrderedSet()->sortedBy(name)) separator ('\n')]
	[aReference.InitReferences()/]
	[/for]
}

std::shared_ptr<ecore::EObject>  [className/]::copy() const
{
	std::shared_ptr<ecore::EObject> element(new [className/](*this));
	return element;
}

std::shared_ptr<[needNamespace(aClass.ePackage, 'EClass')/]> [className/]::eStaticClass() const
{
	return [aClass.ePackage.name.concat('PackageImpl').toUpperFirst()/]::eInstance()->get[aClass.name.toUpperFirst()/]();
}

//*********************************
// Attribute Setter Getter
//*********************************
[for (aAttribute : EAttribute | aClass.eAttributes->asOrderedSet()->sortedBy(name)) separator ('\n')]
[aAttribute.generateAttributeSetterImplementationCpp(true)/]

[aAttribute.generateAttributeGetterImplementationCpp()/]
[/for]

//*********************************
// Operations
//*********************************
[for (aOperation : EOperation | aClass.eOperations->asOrderedSet()->sortedBy(name)) separator ('\n')]
[aOperation.generateOperationImplementation()/]
[/for]

//*********************************
// References
//*********************************
[for (aReference : EReference | aClass.eReferences->asOrderedSet()->sortedBy(name)) separator ('\n')]
[aReference.generateReferenceCpp()/]
[/for]

//*********************************
// Union Getter
//*********************************
[aClass.generateUnionGetterCpp()/]

[aClass.generateEContainerOperationCPP()/]

//*********************************
// Structural Feature Getter/Setter
//*********************************
[aClass.generateeGetImpl()/]

[aClass.generateeSetImpl()/]

//*********************************
// Persistence Functions
//*********************************
void [aClass.name.concat('Impl')/]::load(std::shared_ptr<persistence::interface::XLoadHandler> handler) 
{
try{
	// get EcoreFactory
	std::shared_ptr<ecore::EcoreFactory> factory = ecore::EcoreFactory::eInstance();
	
	//
	// Set Attributes
	//
	// Get list of current Node Attributes	
	std::map<std::string, std::string> attr_list = handler->getAttributeList();
	
	std::map<std::string, std::string>::const_iterator iter;

[for (aAttribute : EAttribute | aClass.eAllAttributes->select(eAtt: EAttribute|(eAtt.transient = false))->asOrderedSet()->sortedBy(name)) separator ('\n')]
  [if (aAttribute.eType.oclIsKindOf(EDataType) and not(aAttribute.eType.name = 'EJavaClass'))]
[comment]
// Attributes that are from type EJavaClass (void*) has not to export to xml. 
[/comment]
	[if (not(aAttribute.upperBound = 1))]
	//handler->addAttribute( "[aAttribute.name/]", this->[aAttribute.GetterName()/]() ); // upperBound != 1 so [aAttribute.GetterName()/]() is a list/bag/union
	// TODO needs an implementation to set list of strings to this attribute
	std::cout << "| ERROR    | " << __PRETTY_FUNCTION__ << " needs an implementation to set list of strings to this attribute." << std::endl; 
	[else]
	iter = attr_list.find("[aAttribute.name/]");
	if ( iter != attr_list.end() )
	{
	  [if (generateType(aAttribute.eType) = 'bool')]
		// this attribute is a 'bool'
		bool value;
		std::istringstream(iter->second) >> std::boolalpha >> value;
	  [elseif ((generateType(aAttribute.eType) = 'int'))]
		// this attribute is a 'int'
		int value;
		std::istringstream ( iter->second ) >> value;
	  [elseif ((generateType(aAttribute.eType) = 'long'))]
		// this attribute is a 'long'
		long value;
		std::istringstream ( iter->second ) >> value;
	  [elseif ((generateType(aAttribute.eType) = 'float'))]
		// this attribute is a 'float'
		float value;
		std::istringstream ( iter->second ) >> value;
	  [elseif ((generateType(aAttribute.eType) = 'double'))]
		// this attribute is a 'double'
		double value;
		std::istringstream ( iter->second ) >> value;
	  [elseif ((generateType(aAttribute.eType) = 'char'))]
		// this attribute is a 'char'
		char value;
		std::istringstream ( iter->second ) >> value;
	  [elseif ((generateType(aAttribute.eType) = 'std::string'))]
		// this attribute is a 'std::string'
		std::string value;
		value = iter->second;
	  [else]
		// TODO this attribute has a non handle type
		std::cout << "| ERROR    | " << __PRETTY_FUNCTION__ << " handle type of '[aAttribute.name/]'" << " [aAttribute.eType/]" << std::endl; 
		value = "";
	  [/if]
		this->[aAttribute.SetterName()/](value);
	}
	[/if]
  [/if]
[/for]
	//
	// Set References (containment == false)
	//
	std::shared_ptr<ecore::EClass> metaClass = this->eClass(); // get MetaClass
[for (aReference : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = false) and (eRef.transient = false) and (eRef.changeable = true))->asOrderedSet()->sortedBy(name)) separator ('\n')]
	iter = attr_list.find("[aReference.name/]");
	if ( iter != attr_list.end() )
	{
		// add unresolvedReference to handler's list
		handler->addUnresolvedReference(iter->second, handler->getCurrentObject(), metaClass->getEStructuralFeature("[aReference.name/]")); // TODO use getEStructuralFeature() with id, for faster access to EStructuralFeature
	}
[/for]

	//
	// Create new objects (from references (containment == true))
	//
	std::cout << handler->getLevel() << "<" << metaClass->getName() << " ";

	std::shared_ptr<ecore::ENamedElement> _[aClass.name/] = std::dynamic_pointer_cast<ecore::ENamedElement>(handler->getCurrentObject());
	if(_[aClass.name/])
	{
		std::cout << "name='"<< _[aClass.name/]->getName() << "'";
	}
	std::cout << ">" << std::endl;


	int numNodes = handler->getNumOfChildNodes();
	std::cout << handler->getLevel() << "-NumNodes: " << numNodes << std::endl;
	
	std::string nodeName;
	for(int ii = 0; ii < numNodes; ii++)
	{
		nodeName = handler->getNextNodeName();
		std::cout << handler->getLevel() << "-Child: "<< nodeName << " " << ii+1 << "/" << numNodes << std::endl;

[for (aReference : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = true) and (eRef.transient = false))->asOrderedSet()->sortedBy(name)) separator ('\n')]
		if ( nodeName.compare("[aReference.name/]") == 0 )
		{
  [if (aReference.upperBound = 1)]
			/* 
			 * Create and load '[aReference.name/]'
			 */
			std::shared_ptr<[aReference.eType.generateType()/]> [aReference.name/];

			// 1. Create new Object '[aReference.name/]' with Factory and set Container to Object 'this.
	[let aEClass : EClass = aReference.eType.oclAsType(EClass)]
			[aReference.name/] = factory->create[aEClass.name/]() ; 
			
			// 1.x Insert '[aReference.name/]' to corresponding container's reference
			this->[aReference.SetterName()/]([aReference.name/]);
	[/let]
  [else]
			/* 
			 * Create and load '[aReference.name/]'
			 */
			std::shared_ptr<[aReference.eType.generateType()/]> [aReference.name/];

			// 1. Create new Object '[aReference.name/]' with Factory and set Container to Object 'this.
			attr_list = handler->getAttributeList();
			iter = attr_list.find("xsi:type");
			if ( iter != attr_list.end() )
			{
				std::string _type = iter->second;
				size_t const double_dot = _type.find(L':', 0);
				std::string _type_ns = _type.substr(0, double_dot); // TODO '_type_ns' is not used in this case
				std::string _type_name = _type.substr(double_dot + 1);
	  [let aEClass : EClass = aReference.eType.oclAsType(EClass)]
		[let ref:OrderedSet(EReference) = aEClass.getAllContainers()]
		[if(ref->size() > 0)]
			[if(ref->size() > 1)]
				// TODO here are multiple containers of same object. Check this!
				std::cout << "| ERROR    |" << __PRETTY_FUNCTION__ << " '[aReference.name/]' has more then one back-reference Object." << std::endl;
			
			[/if]
			[for(aBackReference : EReference | ref->sortedBy(name))]
				[aReference.name/] = std::dynamic_pointer_cast<[aReference.eType.generateType()/]>(factory->create(_type_name, handler->getCurrentObject(), [aReference.metamodelPackageNameForEstructuralFeture(aClass)/]::[aReference.memberNameUpper()/])) ;			
			[/for]
		[else]
				[aReference.name/] = std::dynamic_pointer_cast<[aReference.eType.generateType()/]>( factory->create(_type_name) ); 
		[/if]
			}
			else
			{
		[if(ref->size() > 0)]
			[if(ref->size() > 1)]
				// TODO here are multiple containers of same object. Check this!
				std::cout << "| ERROR    |" << __PRETTY_FUNCTION__ << " '[aReference.name/]' has more then one back-reference Object." << std::endl;
			
			[/if]
			[for(aBackReference : EReference | ref->sortedBy(name))]
				[aReference.name/] = std::dynamic_pointer_cast<[aReference.eType.generateType()/]>(factory->create("[aEClass.name/]", handler->getCurrentObject(), [aReference.metamodelPackageNameForEstructuralFeture(aClass)/]::[aReference.memberNameUpper()/])) ;			
			[/for]
		[else]
				[aReference.name/] = factory->create[aEClass.name/]() ; 
		[/if]
			}
		[if(ref->size() = 0)]
			// 1.x Insert '[aReference.name/]' to corresponding container's reference
			[aReference.generateReferenceType()/] list_[aReference.name/] = this->[aReference.GetterName()/]();
			list_[aReference.name/]->push_back([aReference.name/]);
		[/if]
		[/let]
	  [/let]
  [/if]
			
			// 2. Report Handler to set '[aReference.name/]' as new current Object.
			handler->setCurrentObject([aReference.name/]);

			// 3. Call recursively '[aReference.name/].load().
			[aReference.name/]->load(handler);

			// 4. Add '[aReference.name/]' to Handler's internal Map, that is used for resolving references.
			handler->addToMap([aReference.name/]);
		}
[/for]

		// Report Handler to set 'this' as new current Object.
		handler->release();
	}
}
catch (std::exception& e)
{
	std::cout << e.what() << std::endl;
}
catch (...) 
{
	std::cout << "Exception occurred" << std::endl;
}	
}

void [aClass.name.concat('Impl')/]::resolveReferences(const int featureID, std::list<std::shared_ptr<ecore::EObject> > references)
{
	switch(featureID)
	{
	[for (aReference : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = false) and (eRef.transient = false) and (eRef.changeable = true))->asOrderedSet()->sortedBy(name)) separator ('\n')]
		case [aReference.metamodelPackageNameForEstructuralFeture(aClass)/]::[aReference.memberNameUpper()/]:
		{
		[if (aReference.upperBound = 1)]
			if (references.size() == 1)
			{
				// Cast object to correct type
				std::shared_ptr<[aReference.eGenericType.generateCppType()/]> _[aReference.name/] = std::dynamic_pointer_cast<[aReference.eGenericType.generateCppType()/]>( references.front() );

				// Add object by calling eSet() 
				eSet(featureID, _[aReference.name/]);
			}
			
		[else]
			std::shared_ptr< Bag<[aReference.eGenericType.generateCppType()/]> > _[aReference.name/] = [aReference.GetterName()/]();
			while ( references.size() > 0 )
			{
				std::shared_ptr<[aReference.eGenericType.generateCppType()/]> _r = std::dynamic_pointer_cast<[aReference.eGenericType.generateCppType()/]>( references.front() );
				assert(_r);
				if (_r != nullptr){
					_[aReference.name/]->push_back(_r);
					references.pop_front();
				}				
			}
		[/if]
			break;
		}
	[/for]
	}
}

void [aClass.name.concat('Impl')/]::save(std::shared_ptr<persistence::interface::XSaveHandler> handler) const
{
	// get EcorePackage
	std::shared_ptr<ecore::EcorePackage> package = ecore::EcorePackage::eInstance();	
	
	// get MetaClass
	std::shared_ptr<ecore::EClass> metaClass = this->eClass();
	
	//
	// Add attributes
	//
[for (aAttribute : EAttribute | aClass.eAllAttributes->select(eAtt: EAttribute|(eAtt.transient = false))->asOrderedSet()->sortedBy(name)) separator ('\n')]
  [if (aAttribute.eType.oclIsKindOf(EDataType) and not(aAttribute.eType.name = 'EJavaClass'))]
[comment]
// Attributes that are from type EJavaClass (void*) has not to export to xml. 
[/comment]
	if ( this->eIsSet(package->get[aAttribute.memberName()/]()) )
	{
		handler->addAttribute( "[aAttribute.name/]", this->[aAttribute.GetterName()/]() );
	}
  [else]
	// TODO '[aAttribute.eType/]' Attribute's eType is a EJavaClass or its eClass is not typeof EDataType
  [/if]
[/for]

	//
	// Add references
	//
[for (aReference : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = false) and (eRef.transient = false) and (eRef.changeable = true))->asOrderedSet()->sortedBy(name))]
	[if (aReference.upperBound = 1)]
	handler->addReference("[aReference.name/]", this->[aReference.GetterName()/]());
	[else]
	handler->addReferences("[aReference.name/]", this->[aReference.GetterName()/]());
	[/if]
[/for]

	//
	// Add new tags (from references)
	//

[for (aReference : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = true) and (eRef.transient = false))->asOrderedSet()->sortedBy(name)) separator ('\n')]
	// Save '[aReference.name/]'
	[if (aReference.upperBound = 1)]
	[aReference.generateReferenceType()/] [aReference.name/] = this->[aReference.GetterName()/]();
	if ( [aReference.name/] != nullptr) 
	{
		std::shared_ptr<ecore::EStructuralFeature> esf = metaClass->getEStructuralFeature( "[aReference.name/]" ); // TODO use if instead of string to return ESF

	[else]
	[aReference.generateReferenceType()/] list_[aReference.name/] = this->[aReference.GetterName()/]();
	if ( list_[aReference.name/]->size() != 0) 
	{
		std::shared_ptr<ecore::EStructuralFeature> esf = metaClass->getEStructuralFeature( "[aReference.name/]" ); // TODO use if instead of string to return ESF

		for ( std::shared_ptr<[aReference.eType.generateType()/]> [aReference.name/] : *list_[aReference.name/] ) 
		{
	[/if]
			// 1. Create and add Node-Element to model-tree
			handler->createAndAddElement( "[aReference.name/]" );

			if([aReference.name/]->eClass() != esf->getEType())
			{
				// 1.x Set Attribute "xsi:type" to the specific Class-Type
				handler->addAttribute( "xsi:type", handler->extractType([aReference.name/]) );
			}

			// 2. Recursive call of save()
			[aReference.name/]->save( handler );
			
			// 3. Tell handler for stepping to previous level
			handler->release(); 
	[if (aReference.upperBound = 1)]
	}
	[else]
		}
	}
	[/if]
[/for]

}
[/file]
[/template]